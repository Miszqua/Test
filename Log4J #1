let log4jioc = dynamic(["jndi","ldap","${::"]);
AzureDiagnostics
| where ResourceProvider == "MICROSOFT.NETWORK" and Category in ("ApplicationGatewayFirewallLog", "FrontdoorWebApplicationFirewallLog")
| extend details_data_s = column_ifexists("details_data_s", tostring(AdditionalFields.details_data))
|where requestUri_s has_any (log4jioc) or details_message_s has_any (log4jioc) or details_data_s has_any (log4jioc)
| extend Malicious = iff(isnotempty( details_data_s),details_data_s,iff(isnotempty( requestUri_s),requestUri_s,""))
|parse Malicious with * '${' MaliciousCommand '}' * 
| extend EncodeCmd = iff(MaliciousCommand has 'Base64/', split(split(MaliciousCommand, "Base64/",1)[0], "}", 0)[0], "")
| extend EncodeCmd1 = iff(MaliciousCommand has 'base64/', split(split(MaliciousCommand, "base64/",1)[0], "}", 0)[0], "")
| extend CmdLine = iff( isnotempty(EncodeCmd), EncodeCmd, EncodeCmd1)
| extend DecodedCmdLine = base64_decode_tostring(tostring(CmdLine))
| extend DecodedCmdLine = iff( isnotempty(DecodedCmdLine), DecodedCmdLine, "Unable to decode/Doesn't need decoding")
| project TimeGenerated, Target=column_ifexists("hostname_s", tostring(AdditionalFields.hostname)), MaliciousHost = column_ifexists("clientIp_s", tostring(AdditionalFields.clientIp)) , MaliciousCommand, details_data_s = column_ifexists("details_data_s", tostring(AdditionalFields.details_data)), DecodedCmdLine, Message,
ruleSetType_s = column_ifexists("ruleSetType_s", tostring(AdditionalFields.ruleSetType)), OperationName, SubscriptionId, details_message_s = column_ifexists("details_message_s", tostring(AdditionalFields.details_message)), 
details_file_s = column_ifexists("details_message_s", tostring(AdditionalFields.details_file))
| extend timestamp = TimeGenerated

///////////////////////////


// ---- Production-ready Log4Shell (CVE-2021-44228) detection for Azure WAF / Front Door ----

let lookback = 1h;
let jndi_regex = @"\$\{.*?(j|\\u006a).*?(n|\\u006e).*?(d|\\u0064).*?(i|\\u0069).*?:.*?\}";
let waf_logs =
    AzureDiagnostics
    | where TimeGenerated > ago(lookback)
    | where ResourceProvider == "MICROSOFT.NETWORK"
      and Category in ("ApplicationGatewayFirewallLog", "FrontdoorWebApplicationFirewallLog")
    | extend 
        details_data_s = column_ifexists("details_data_s", tostring(AdditionalFields.details_data)),
        details_message_s = column_ifexists("details_message_s", tostring(AdditionalFields.details_message)),
        hostname_s = column_ifexists("hostname_s", tostring(AdditionalFields.hostname)),
        clientIp_s = column_ifexists("clientIp_s", tostring(AdditionalFields.clientIp)),
        RawFields = strcat(requestUri_s, " ", details_message_s, " ", details_data_s, " ", httpUserAgent_s);
waf_logs
| extend JndiMatch = extract(jndi_regex, 0, RawFields)
| where isnotempty(JndiMatch)
| extend Base64Blob = extract(@"(?:Base64/|base64/)([A-Za-z0-9+/=]+)", 1, RawFields)
| extend Decoded = iff(isnotempty(Base64Blob), base64_decode_tostring(Base64Blob), "")
| project 
      TimeGenerated,
      SrcIp = clientIp_s,
      TargetHost = hostname_s,
      RawRequestUri = requestUri_s,
      WAF_Message = details_message_s,
      WAF_Data = details_data_s,
      JndiMatch,
      Decoded,
      Category,
      ResourceId,
      SubscriptionId
| summarize 
      FirstSeen = min(TimeGenerated),
      LastSeen = max(TimeGenerated),
      Hits = count(),
      SamplePayload = any(JndiMatch),
      SampleDecoded = any(Decoded)
      by SrcIp, TargetHost
| order by LastSeen desc

///////////////

// ---- Parametry i wzorce ----
let lookback = 1h;
// Wzorce JNDI + popularne protokoły wykorzystywane w Log4Shell
let jndiTokens = dynamic([
  "${jndi", "jndi:", "ldap:", "rmi:", "dns:", "ldaps:", "iis:", "nis:", "nds:"
]);
// Regex wyłapujący klasyczne i obfuskowane formy JNDI (np. ${${::-j}${::-n}di:ldap://...})
let jndiRegex = @"\$\{\s*(?:\$\{[^}]*\}\s*)*j\s*[\W_]*n\s*[\W_]*d\s*[\W_]*i\s*[:][^}]+\}";
// Funkcja ekstrakcji wskaźnika JNDI
let extract_jndi = (text:string) { extract(jndiRegex, 0, text) };
// ---- Zródła 1) Azure WAF / AppGW (AzureDiagnostics) ----
let waf =
AzureDiagnostics
| where TimeGenerated > ago(lookback)
| project TimeGenerated,
          SrcIp = tostring(CallerIPAddress),
          DstHost = tostring(host_s),
          Url = tostring(RequestUri_s),
          UserAgent = tostring(httpUserAgent_s),
          Raw = tostring(RequestUri_s) // pod UserAgent i inne pola niżej też zbadamy
| extend Indicator = coalesce(extract_jndi(Url), extract_jndi(UserAgent))
| where isnotempty(Indicator)
| project TimeGenerated, SrcIp, DstHost, Url, UserAgent, Indicator, SourceTable = "AzureDiagnostics";
// ---- Źródła 2) IIS / Web serwery (W3CIISLog) ----
let iis =
W3CIISLog
| where TimeGenerated > ago(lookback)
| extend Url = strcat(csUriStem, iif(isnotempty(csUriQuery), strcat("?", csUriQuery), "")),
        UserAgent = tostring(csUserAgent)
| extend Indicator = coalesce(extract_jndi(Url), extract_jndi(UserAgent))
| where isnotempty(Indicator)
| project TimeGenerated,
          SrcIp = cIP, DstHost = sComputerName, Url, UserAgent, Indicator,
          SourceTable = "W3CIISLog";
// ---- Źródła 3) Firewalle/Proxy (CEF/LEEF) (CommonSecurityLog) ----
let cef =
CommonSecurityLog
| where TimeGenerated > ago(lookback)
| extend Url = coalesce(RequestURL, DeviceCustomString1, DeviceCustomString2, RequestClientApplication)
| extend UserAgent = coalesce(DeviceCustomString4, DeviceCustomString3, AdditionalExtensions)
| extend Indicator = coalesce(extract_jndi(tostring(Url)), extract_jndi(tostring(UserAgent)))
| where isnotempty(Indicator)
| project TimeGenerated,
          SrcIp = SourceIP, DstHost = DestinationHostName, Url, UserAgent, Indicator,
          SourceTable = "CommonSecurityLog";
// ---- Połącz i usuń duplikaty ----
union isfuzzy=true waf, iis, cef
| summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated), Hits=count(), Urls=make_set(Url, 50), UserAgents=make_set(UserAgent, 50), Sources=make_set(SourceTable)
          by SrcIp, DstHost, Indicator
| order by LastSeen desc
